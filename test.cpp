/*
解题思路
请在此处填写你的解题思路 一开始看到这题标签是暴力，就想都没想先前缀和再枚举每一区间，结果超时了，然后看了题解才知道，前缀和是基本要想到了，但是后面不能暴力枚举，要用用点技巧（不知道是不是数学技巧），反正我想了好久。
好了，说一下我的总结吧！就是再加一个数组记录这个余数的前缀区间有几个（至于为什么后面会说），然后我们在想一下当两个数除以K的余数相同时，将他们相减之后是不是能被K整除（如：k=3,a1=4,b=7），我们会惊奇的发现是可以的，
利用这个技巧，我们可以在求前缀和的时候判断一下这个前缀区间模上K的余数，并计数（cnt[]）,然后再想一下，我们用前缀和求任意一个区间是怎么求得？
这样当我们再在判断余数的时候，加上之前也是这个余数的前缀区间的集合数量，因为只要我这个有和前面任何一个余数相同，都能得到一个被K整除的区间（并且还不一样），利用这个我们可得到优化。还有其他的具体的请看代码注释。
*/

#include <iostream>
using namespace std;
const int N=100010;
//因为是前缀和，数还是比较大的
long long  a[N];
//这里cnt[]最差情况也就所有数的余数相同（最大也就100000），不需要long long
int cnt[N];
int main()
{
  int n,m;
  cin>>n>>m;
//余数为0说明本身就是可已被整除（可以模拟一下，如果初始为零会有有什么后果，这里就不说了）
  cnt[0]=1;
//一般像求这种区间数量的，都非常大要long long
  long long res=0;
  for(int i=1;i<=n;i++){
//自己前缀自己
    scanf("%d",&a[i]);
    a[i]+=a[i-1];
    //加上之前和自己有相同余数的区间数量（两个构成一个可以被K整除的区间）
    res+=cnt[a[i]%m];
//累加自己，因为后面还有可能有可以和他组成可被K整除的区间
    cnt[a[i]%m]++;
  }
  cout<<res<<endl;
  return 0;
}
